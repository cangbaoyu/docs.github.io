import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c,e as t}from"./app-Bu8N3Y5k.js";const r={};function i(d,o){return n(),c("div",null,o[0]||(o[0]=[t('<h1 id="synchronized-与-lock-的区别" tabindex="-1"><a class="header-anchor" href="#synchronized-与-lock-的区别"><span>synchronized 与 lock 的区别</span></a></h1><ul><li><p><strong>synchronized 和 lock 的用法区别</strong></p><ul><li><strong>synchronized(隐式锁)</strong>：在需要同步的对象中加入此控制，<code>synchronized</code> 可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。</li><li><strong>lock（显示锁）</strong>：需要显示指定起始位置和终止位置。一般使用 <code>ReentrantLock</code> 类做为锁，多个线程中必须要使用一个 <code>ReentrantLock</code> 类做为对象才能保证锁的生效。且在加锁和解锁处需要通过 <code>lock()</code> 和 <code>unlock()</code> 显示指出。所以一般会在 <code>finally</code> 块中写 <code>unlock()</code> 以防死锁。</li></ul></li><li><p>synchronized 和 lock 性能区别 <code>synchronized</code> 是托管给 JVM 执行的，而 <code>lock</code> 是 Java 写的控制锁的代码。在 <strong>JDK 1.5</strong> 中，synchronize 是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用 Java 提供的 <code>Lock</code> 对象，性能更高一些。但是到了 <strong>JDK 1.6</strong>，发生了变化。<code>synchronize</code> 在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在 JDK 1.6 上 <code>synchronize</code> 的性能并不比 <code>Lock</code> 差。</p></li><li><p><strong>synchronized 和 lock 机制区别</strong></p><ul><li><code>synchronized</code> 原始采用的是 CPU 悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。</li><li><code>Lock</code> 用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是 CAS 操作（Compare and Swap）。</li></ul></li></ul>',2)]))}const l=e(r,[["render",i],["__file","Java-Locking4.html.vue"]]),p=JSON.parse('{"path":"/audition/threads/Java-Locking4.html","title":"synchronized 与 lock 的区别","lang":"zh-CN","frontmatter":{"description":"synchronized 与 lock 的区别 synchronized 和 lock 的用法区别 synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized 可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。 lock（显示锁）：需要显示指定起始位置和终止位置。一般使用 ReentrantLock 类做为...","head":[["meta",{"property":"og:url","content":"https://www.sansei.top/audition/threads/Java-Locking4.html"}],["meta",{"property":"og:site_name","content":"川上富江"}],["meta",{"property":"og:title","content":"synchronized 与 lock 的区别"}],["meta",{"property":"og:description","content":"synchronized 与 lock 的区别 synchronized 和 lock 的用法区别 synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized 可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。 lock（显示锁）：需要显示指定起始位置和终止位置。一般使用 ReentrantLock 类做为..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-17T16:19:49.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-17T16:19:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"synchronized 与 lock 的区别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-17T16:19:49.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1731860389000,"updatedTime":1731860389000,"contributors":[{"name":"cangbao","email":"yph0228@163.com","commits":1}]},"readingTime":{"minutes":1.46,"words":437},"filePathRelative":"audition/threads/Java-Locking4.md","localizedDate":"2024年11月17日","autoDesc":true}');export{l as comp,p as data};
